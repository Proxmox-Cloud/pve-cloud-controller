release_tag:
  stage: build
  image: docker.io/tobiashvmz/pve-cloud-ci:2025122115
  script:
    - pwd
    - /scripts/release-tag.sh
  rules:
    - if: '$CI_COMMIT_TAG =~ /^release-[a-z]+$/'
    - if: '$CI_COMMIT_TAG =~ /^release-all-[a-z]+$/'
  resource_group: deploy-prod


# pipeline trigger if the upstream releases
py_pve_cloud_upstream:
  stage: build
  image: docker.io/tobiashvmz/pve-cloud-ci:2025122115
  script:
    - echo $UPSTREAM_TAG_MESSAGE
    - echo $PY_PVE_CLOUD
    # check if the upstream is a rc version
    # if rc version create rc branch if it exists / otherwise checkout and merge current changes in
    # replace with rc version constraint
    # trigger rc release tag pipeline
    - |
      if [[ "$UPSTREAM_TAG_MESSAGE" == rc-* ]]; then

        # set config based on the current commit for auto commit
        git config --global user.name "$GITLAB_USER_NAME"
        git config --global user.email "$GITLAB_USER_EMAIL"

        # find the / determine the rc tag bases on latest prod tag
        tags=$(git tag -l | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' || true)
        if [ -z "$tags" ]; then
          latest_tag="0.0.0"
        else
          latest_tag=$(echo "$tags" | sort -V | tail -n 1)
        fi

        # split the tag and increment
        major=$(echo "$latest_tag" | cut -d '.' -f 1)
        minor=$(echo "$latest_tag" | cut -d '.' -f 2)
        patch=$(echo "$latest_tag" | cut -d '.' -f 3)

        if [[ "$UPSTREAM_TAG_MESSAGE" == *"-major" ]]; then
          major=$((major + 1))
          minor=0
          patch=0
        elif [[ "$UPSTREAM_TAG_MESSAGE" == *"-minor" ]]; then
          minor=$((minor + 1))
          patch=0
        elif [[ "$UPSTREAM_TAG_MESSAGE" == *"-patch" ]]; then
          patch=$((patch + 1))
        else
          echo "Unknown increment type: $UPSTREAM_TAG_MESSAGE"
          exit 1
        fi

        new_tag="$major.$minor.$patch"

        # create / switch to the rc branch
        git checkout ${new_tag}-rc 2>/dev/null || git checkout -b ${new_tag}-rc

        git merge $CI_COMMIT_SHA # merge in recent changes in case its not up to date

        # fix the version to the rcX
        sed -i "s/^py-pve-cloud.*$/py-pve-cloud==${PY_PVE_CLOUD}/" requirements.txt

        # create rc tag and propagate
        rc_tags=$(git tag -l | grep -E "^${new_tag}-rc[0-9]+$" || true)

        # create / increment
        if [ -z "$rc_tags" ]; then
          rc_tag="${new_tag}-rc0"
        else
          latest_rc=$(echo "$rc_tags" | sort -V | tail -n 1)
          rc_num=${latest_rc##*-rc}   # removes everything up to last "-rc"
          
          next_rc=$((rc_num + 1))
          
          rc_tag="${new_tag}-rc${next_rc}"
        fi

        git push origin ${new_tag}-rc # push the full rc branch

        # rc tag and push
        git tag "${rc_tag}" -m "$UPSTREAM_TAG_MESSAGE"
        git push origin "${rc_tag}"

        sleep 10

        # trigger rc build
        curl --request POST \
          --form "token=${CI_JOB_TOKEN}" \
          --form "ref=${rc_tag}" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/trigger/pipeline"

        # exit for now (unclean)
        exit 0
      fi

    # write the new version
    - PESSIMISTIC_CONSTRAINT=$(/scripts/get-pessimistic-semver.sh $PY_PVE_CLOUD)
    - sed -i "s/^py-pve-cloud>=.*$/py-pve-cloud>=${PY_PVE_CLOUD},<${PESSIMISTIC_CONSTRAINT}/" requirements.txt
    - /scripts/upstream-push.sh "Update py-pve-cloud version to $PY_PVE_CLOUD (pessimistic)"
  rules:
    - if: ( $PY_PVE_CLOUD != null || $PY_PVE_CLOUD =~ /^./ ) # set by upstream


# call the pipeline for the release patch tag we just created above - not included in default pipelines
trigger_upstream_release_tag:
  stage: deploy
  image: alpine/curl:8.14.1
  script:
    - |
      curl --request POST \
        --form "token=${CI_JOB_TOKEN}" \
        --form "ref=${UPSTREAM_TAG_MESSAGE}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/trigger/pipeline"
  rules:
    - if: $UPSTREAM_TAG_MESSAGE =~ /-all-/ && ( $PY_PVE_CLOUD != null || $PY_PVE_CLOUD =~ /^./ ) # set by upstream


# actual image build and release
release_image:
  stage: deploy
  retry: 1 # even with check logic for pypi package rdy on index, calls after still sometimes fail
  image:
    name: quay.io/podman/stable:v5.7.1
  script:
    # exit if ci vars are not defined for building
    - |
      if [ -z $DOCKER_AUTH_CONFIG_B64 ]; then
        echo "Docker auth ci variable not defined!"
        exit 0
      fi
    - mkdir -p /root/.config/containers
    - echo $DOCKER_AUTH_CONFIG_B64 | base64 -d > /root/.config/containers/auth.json
    - echo "__version__ = \"$CI_COMMIT_TAG\"" > src/pve_cloud_ctrl/_version.py 
    - podman build --layers --cache-from tobiashvmz/pve-cloud-controller-cache --cache-to tobiashvmz/pve-cloud-controller-cache -t tobiashvmz/pve-cloud-controller:$CI_COMMIT_TAG .
    - podman push tobiashvmz/pve-cloud-controller:$CI_COMMIT_TAG
  rules:
    - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+$/'
    - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+-rc\d+$/' # rcs

downstream_tf_controller_module:
  stage: deploy
  trigger:
    project: "pve-cloud/terraform-pxc-controller"
  variables:
    PVE_CLOUD_CONTROLLER: $CI_COMMIT_TAG
    UPSTREAM_TAG_MESSAGE: $CI_COMMIT_TAG_MESSAGE
  rules:
    - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+$/' # semver


format_source:
  stage: build
  image: tobiashvmz/pve-cloud-pyci:2026010412
  script:
    - git config --global user.name "$GITLAB_USER_NAME"
    - git config --global user.email "$GITLAB_USER_EMAIL"
    
    - autoflake --in-place --recursive .
    - black .
    - isort .
    # commit the changes
    - |
      if ! git diff --quiet; then
        git add .
        git commit -m "Format and cleanup pipeline"
        git push origin HEAD:$CI_COMMIT_REF_NAME
      else
        echo "Nothing to clean or format!"
      fi
  rules:
    - if: >
        $CI_COMMIT_TAG !~ /^\d+\.\d+\.\d+$/ &&
        $CI_COMMIT_TAG !~ /^release-[a-z]+$/ &&
        $CI_COMMIT_TAG !~ /^release-all-[a-z]+$/ &&
        $CI_PIPELINE_SOURCE == 'push'
      when: on_success
    - when: never
  resource_group: deploy-prod